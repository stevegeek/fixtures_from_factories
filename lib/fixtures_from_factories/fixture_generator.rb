# frozen_string_literal: true

require "factory_bot"
require "faker"

module FixturesFromFactories
  class FixtureGenerator
    attr_reader :model_cache, :name_config, :excluded_tables, :output_path

    def initialize(
      output_path,
      excluded_tables = FixturesFromFactories.configuration.excluded_tables
    )
      @model_cache = {}
      @name_config = {}
      @output_path = output_path
      @excluded_tables = excluded_tables
    end

    def generate(&blk)
      instance_eval(&blk)
      dump_tables
      dump_record_index
    end

    # Record creation DSL

    # Create a single named record using FactoryBot
    def create(name_or_prefix, factory_or_index, *bot_args)
      item_name, factory =
        if factory_or_index.is_a?(Symbol) || factory_or_index.is_a?(Array)
          [name_or_prefix, factory_or_index]
        else
          ["#{name_or_prefix}_#{factory_or_index}".to_sym, bot_args.shift]
        end

      Rails.logger.info "Creating record: #{item_name}"
      record = FactoryBot.create(*(Array.wrap(factory) + bot_args))
      if record.nil? || !record.persisted?
        raise StandardError, "A record failed to save, #{record.class.name}, #{bot_args}"
      end
      add_record(item_name, record)
      record
    end

    # Create multiple records from factory within index range, where the name has the index appended
    def create_multiple(name, factory, start_index, end_index, items = nil)
      (start_index..end_index).map.with_index do |instance_num, index|
        bot_args = block_given? ? yield(instance_num) : items&.at(index)
        create(name, instance_num, factory, bot_args)
      end
    end

    def create_multiple_with_names(name_prefix, factory, names, items = nil)
      names.map.with_index do |config, index|
        parts = config.is_a?(Hash) ? config[:names] : config
        n_index = Array.wrap(parts).map { |s| s.to_s.parameterize.underscore }.join("_").to_sym
        n = "#{name_prefix}_#{n_index}".to_sym
        bot_args = block_given? ? yield(n, n_index, config, index) : items&.at(index)
        create(n, factory, bot_args)
      end
    end

    # Get an existing record
    def get(name, index = nil)
      model_cache.fetch(index.present? ? "#{name}_#{index}".to_sym : name)[:record]
    end

    def generate_name_from_humanized(model, *parts)
      "#{model}_#{parts.map { |s| s.to_s.parameterize.underscore }.join("_")}".to_sym
    end

    # Setup naming logic for a specific table
    def configure_name(model_klass, *attrs)
      name_config[model_klass.name] = {klass: model_klass, attrs: attrs}
      name_config[model_klass.name] = ->(record, other) do
        attrs.all? { |attr| record.attributes[attr.to_s] == other[attr.to_s] }
      end
    end

    def add_record(item_name, record)
      raise "Adding nil record! #{item_name}" if record.nil?
      Rails.logger.info "Adding record #{item_name}..."
      model_cache.merge!({item_name => cached_record(record)}) do |key|
        raise "Duplicate key: #{key}"
      end
    end

    def add_collection(collection, collection_name: nil)
      c_name = collection_name || collection.name.underscore
      added_count = 0
      collection.find_in_batches do |group|
        group.each do |model|
          id = block_given? ? yield(model) : model.id.to_s
          name = "#{c_name}_#{id}".to_sym
          add_record(name, model)
          added_count += 1
        end
      end
      added_count
    end

    def make_fake_time(from, to)
      Faker::Time.between(from: from.utc, to: to.utc).utc
    end

    private

    def dump_record_index
      path = File.join(output_path, "record_index.txt")
      File.open(File.expand_path(path), "w") do |file|
        file.write "# ----------------------------------------------------------------------------\n"
        file.write "# Do not edit this file manually! It is generated by ./db/generate_fixtures.rb\n"
        file.write "# ----------------------------------------------------------------------------\n"
        file.write model_cache.keys.join("\n")
      end
    end

    def cached_record(record)
      {
        record: record,
        klass: record.class,
        comparison: ->(record, other) do
          if name_config[record.class.name]
            name_config[record.class.name].call(record, other)
          elsif record.id.present?
            record.id.to_s == other["id"]&.to_s
          else
            raise StandardError,
              "You maybe missing a call to `configure_name` for a table without a primary id key"
          end
        end
      }
    end

    def class_from_table(table_name)
      table_name.classify.constantize
    rescue
      nil
    end

    def get_record_name(needle, table_name)
      generate_record_name(needle, table_name, nil)
    end

    # Based on https://github.com/rdy/fixture_builder
    def generate_record_name(needle, table_name, row_index)
      table_klass = class_from_table(table_name)
      generated_name =
        if table_klass
          generate_record_name_with_model(needle, table_klass, row_index)
        elsif row_index
          [table_name, row_index.succ!].join("_")
        end

      generated_name&.to_s
    end

    def generate_record_name_with_model(needle, table_klass, row_index)
      found_name = get_record_name_from_cache(needle, table_klass)
      if found_name.present?
        found_name
      elsif row_index
        [table_klass.name, row_index.succ!].join("_")
      end
    end

    def get_record_name_from_cache(needle, table_klass)
      # Check if the model is in the cache and get its name, otherwise generate a name from a sequence
      # Note if row_index is not set and the model isnt in the cache (ie it was not explicitly created by us) then
      # nil is returned
      klasses = [table_klass]
      klasses.concat(table_klass.subclasses) if table_klass.subclasses.present?
      found_name =
        model_cache.find do |_key, cached|
          klasses.include?(cached[:klass]) && cached[:comparison].call(cached[:record], needle)
        end
      found_name&.first
    end

    # Taken from https://github.com/rdy/fixture_builder
    def tables
      ActiveRecord::Base.connection.tables - excluded_tables
    end

    # Based on https://github.com/rdy/fixture_builder but we replace references with a named reference and let Rails
    # generate stable IDs. In cases where a record has been created indirectly by a factory (and not explicity by this
    # generator) it will stay as a reference with a hardcoded ID
    def dump_tables
      default_date_format = Date::DATE_FORMATS[:default]
      Date::DATE_FORMATS[:default] = Date::DATE_FORMATS[:db]
      begin
        fixtures =
          tables.inject([]) do |files, table_name|
            rows = process_table(table_name)
            next files if rows.empty?

            fixture_data = prepare_fixture_data(rows, table_name)
            write_fixture_file(fixture_data, table_name)
            files + [File.basename(fixture_file(table_name))]
          end
      ensure
        Date::DATE_FORMATS[:default] = default_date_format
      end
      Rails.logger.info "Built #{fixtures.to_sentence}"
    end

    def process_table(table_name)
      table_klass = class_from_table(table_name)
      if table_klass && table_klass < ActiveRecord::Base
        process_table_with_model(table_klass)
      else
        process_table_without_model(table_name)
      end
    end

    def process_table_with_model(table_klass)
      table_klass.unscoped do
        table_klass.all.map do |obj|
          attrs = obj.attributes.select { |attr_name| table_klass.column_names.include?(attr_name) }
          attrs.each_with_object({}) do |(attr_name, value), hash|
            replace_association_with_named(table_klass, attrs, hash, attr_name, value)
          end
        end
      end
    end

    # Some records are
    def replace_association_with_named(table_klass, attrs, hash, attr_name, value)
      # If the record attribute is a relation, then get the other model name and use it instead of a ID value
      # but only if there is a AR model for the table
      attr_name_without_id = attr_name.sub(/_id$/, "")
      reflection = table_klass.reflect_on_association(attr_name_without_id)
      if reflection&.kind_of?(ActiveRecord::Reflection::AssociationReflection) && value.present?
        related_klass_name =
          begin
            # Polymorphic
            association_type = attrs[attr_name_without_id + "_type"]
            association_type.presence || reflection.class_name
          end
        other_name = get_record_name({"id" => value}, related_klass_name.constantize.table_name)
        if other_name
          hash[attr_name_without_id] = other_name.to_s
          return hash
        end
      end
      hash[attr_name] = serialized_value_if_needed(table_klass, attr_name, value)
    end

    # Some tables have no model (eg joins) and should be dumped.
    def process_table_without_model(table_name)
      ActiveRecord::Base
        .connection
        .select_all(
          "SELECT * FROM %<table>s" % {
            table: ActiveRecord::Base.connection.quote_table_name(table_name)
          }
        )
        .map do |row|
          row.each_with_object({}) do |(attr_name, value), hash|
            # If the record attribute is a relation, then get the other model name and use it instead of a ID value
            if attr_name.end_with?("_id") && value.present?
              attr_name_without_id = attr_name.sub(/_id$/, "")
              klass = class_from_table(attr_name_without_id)
              if klass
                other_name = get_record_name({"id" => value}, klass.table_name)

                # Note when there is no model for the table then retain '_id' attr name, as the fixtures setup code
                # doesnt know about a relation named with the value of <attr_name_without_id> since there is no Model class
                hash[attr_name] = other_name ? other_name.to_s : value
              else
                hash[attr_name] = value
              end
            else
              hash[attr_name] = value
            end
          end
        end
    end

    def prepare_fixture_data(rows, table_name)
      # This will be mutated by calls to generate_record_name in cases where the index is needed
      row_index = +"000"
      rows.inject({}) do |hash, record|
        # If this was created by us, dont store the ID, use the rails stable ID
        obj_name = get_record_name(record, table_name)
        record_name = generate_record_name(record, table_name, row_index)
        if obj_name
          Rails.logger.debug "Writing #{obj_name} (#{table_name})"
          record.delete("id")
        else
          Rails
            .logger.debug "Writing a record which was created indirectly by a factory (#{table_name})"
        end
        hash.merge(record_name => record)
      end
    end

    # Taken from https://github.com/rdy/fixture_builder
    def serialized_value_if_needed(table_klass, attr_name, value)
      if table_klass.respond_to?(:type_for_attribute)
        serialize_according_to_type(table_klass, attr_name, value)
      elsif table_klass.serialized_attributes.has_key? attr_name
        table_klass.serialized_attributes[attr_name].dump(value)
      else
        value
      end
    end

    def serialize_according_to_type(klass, attr_name, value)
      attr_type = klass.type_for_attribute(attr_name)
      if attr_type.type == :jsonb || attr_type.type == :json
        value
      elsif attr_type.type == :time
        # Serialise as an ActiveSupport::TimeWithZone
        value
      elsif attr_type.respond_to?(:serialize)
        attr_type.serialize(value)
      elsif attr_type.respond_to?(:type_cast_for_database)
        attr_type.type_cast_for_database(value)
      else
        attr_type.type_cast_for_schema(value)
      end
    end

    def write_fixture_file(fixture_data, table_name)
      File.open(fixture_file(table_name), "w") do |file|
        file.write "# ----------------------------------------------------------------------------\n"
        file.write "# Do not edit this file manually! It is generated by ./db/generate_fixtures.rb\n"
        file.write "# ----------------------------------------------------------------------------\n"
        file.write fixture_data.to_yaml
      end
    end

    def fixture_file(table_name)
      File.expand_path(File.join(output_path, "#{table_name}.yml"))
    end
  end
end
